{"version":3,"sources":["hooks/useresizeobserver.js","components/timeseries.js"],"names":["useResizeObserver","ref","useState","dimensions","setDimensions","useEffect","observeTarget","current","resizeObserver","ResizeObserver","entries","observer","forEach","entry","index","contentRect","observe","unobserve","React","memo","timeseries","dates","chartType","isUniform","isLog","t","useTranslation","refs","useRef","wrapperRef","highlightedDate","setHighlightedDate","length","T","getBoundingClientRect","width","height","margin","chartRight","chartBottom","xScale","d3","clamp","domain","parseIndiaDate","range","numTicksX","xAxis","g","attr","call","ticks","tickFormat","date","formatDate","xAxis2","yScale","tickValues","tickSize","select","style","yAxis","tickPadding","uniformScaleMin","getStatistic","uniformScaleMax","Math","max","yScaleUniformLinear","nice","yScaleUniformLog","mousemove","xm","this","invert","bisectDate","left","dateLeft","dateRight","mouseout","i","svg","transition","duration","D3_TRANSITION_DURATION","statistic","TIMESERIES_STATISTICS","min","generateYScale","color","COLORS","selectAll","data","join","enter","append","remove","pathLength","line","curve","x","y","getTotalLength","update","attrTween","previous","interpolatePath","on","getStatisticDelta","useCallback","deltaToday","yesterday","formatISO","subDays","representation","Fragment","className","map","delta","key","classnames","capitalize","formatNumber","element","preserveAspectRatio","prevProps","currProps","equal","stateCode"],"mappings":"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","file":"static/js/TimeSeries.8e7f869b.chunk.js","sourcesContent":["import {ResizeObserver} from '@juggle/resize-observer';\nimport {useState, useEffect} from 'react';\n\nexport const useResizeObserver = (ref) => {\n  const [dimensions, setDimensions] = useState(null);\n  useEffect(() => {\n    const observeTarget = ref.current;\n    const resizeObserver = new ResizeObserver((entries, observer) => {\n      entries.forEach((entry, index) => {\n        setDimensions(entry.contentRect);\n      });\n    });\n    resizeObserver.observe(observeTarget);\n    return () => {\n      resizeObserver.unobserve(observeTarget);\n    };\n  }, [ref]);\n  return dimensions;\n};\n\nexport default useResizeObserver;\n","import {\n  COLORS,\n  D3_TRANSITION_DURATION,\n  TIMESERIES_STATISTICS,\n} from '../constants';\nimport {useResizeObserver} from '../hooks/useresizeobserver';\nimport {\n  capitalize,\n  formatNumber,\n  formatDate,\n  getStatistic,\n  parseIndiaDate,\n} from '../utils/commonfunctions';\n\nimport classnames from 'classnames';\nimport * as d3 from 'd3';\nimport {interpolatePath} from 'd3-interpolate-path';\nimport {formatISO, subDays} from 'date-fns';\nimport equal from 'fast-deep-equal';\nimport React, {useCallback, useEffect, useRef, useState} from 'react';\nimport {useTranslation} from 'react-i18next';\n\nfunction TimeSeries({timeseries, dates, chartType, isUniform, isLog}) {\n  const {t} = useTranslation();\n  const refs = useRef([]);\n\n  const wrapperRef = useRef();\n  const dimensions = useResizeObserver(wrapperRef);\n\n  const [highlightedDate, setHighlightedDate] = useState();\n\n  useEffect(() => {\n    setHighlightedDate(dates[dates.length - 1]);\n  }, [dates]);\n\n  useEffect(() => {\n    const T = dates.length;\n\n    const {width, height} =\n      dimensions || wrapperRef.current.getBoundingClientRect();\n\n    // Margins\n    const margin = {top: 15, right: 35, bottom: 25, left: 25};\n    const chartRight = width - margin.right;\n    const chartBottom = height - margin.bottom;\n\n    const yBufferTop = 1.2;\n    const yBufferBottom = 1.1;\n\n    const xScale = d3\n      .scaleTime()\n      .clamp(true)\n      .domain([parseIndiaDate(dates[0]), parseIndiaDate(dates[T - 1])])\n      .range([margin.left, chartRight]);\n\n    // Number of x-axis ticks\n    const numTicksX = width < 480 ? 4 : 7;\n\n    const xAxis = (g) =>\n      g.attr('class', 'x-axis').call(\n        d3\n          .axisBottom(xScale)\n          .ticks(numTicksX)\n          .tickFormat((date) => formatDate(date, 'dd MMM'))\n      );\n\n    const xAxis2 = (g, yScale) => {\n      g.attr('class', 'x-axis2')\n        .call(d3.axisBottom(xScale).tickValues([]).tickSize(0))\n        .select('.domain')\n        .style('transform', `translateY(${yScale(0)}px)`);\n\n      if (yScale(0) !== chartBottom) g.select('.domain').attr('opacity', 0.4);\n      else g.select('.domain').attr('opacity', 0);\n    };\n\n    const yAxis = (g, yScale) =>\n      g\n        .attr('class', 'y-axis')\n        .call(d3.axisRight(yScale).ticks(4, '0~s').tickPadding(4));\n\n    const uniformScaleMin = d3.min(dates, (date) =>\n      getStatistic(timeseries[date], chartType, 'active')\n    );\n\n    const uniformScaleMax = d3.max(dates, (date) =>\n      Math.max(\n        getStatistic(timeseries[date], chartType, 'confirmed'),\n        getStatistic(timeseries[date], chartType, 'recovered'),\n        getStatistic(timeseries[date], chartType, 'deceased')\n      )\n    );\n\n    const yScaleUniformLinear = d3\n      .scaleLinear()\n      .clamp(true)\n      .domain([uniformScaleMin, Math.max(1, yBufferTop * uniformScaleMax)])\n      .nice(4)\n      .range([chartBottom, margin.top]);\n\n    const yScaleUniformLog = d3\n      .scaleLog()\n      .clamp(true)\n      .domain([\n        Math.max(1, uniformScaleMin),\n        Math.max(10, yBufferTop * uniformScaleMax),\n      ])\n      .nice(4)\n      .range([chartBottom, margin.top]);\n\n    const generateYScale = (statistic) => {\n      if (isUniform && chartType === 'total' && isLog && statistic !== 'tested')\n        return yScaleUniformLog;\n\n      if (isUniform && statistic !== 'tested') return yScaleUniformLinear;\n\n      if (chartType === 'total' && isLog)\n        return d3\n          .scaleLog()\n          .clamp(true)\n          .domain([\n            Math.max(\n              1,\n              d3.min(dates, (date) =>\n                getStatistic(timeseries[date], chartType, statistic)\n              )\n            ),\n            Math.max(\n              10,\n              yBufferTop *\n                d3.max(dates, (date) =>\n                  getStatistic(timeseries[date], chartType, statistic)\n                )\n            ),\n          ])\n          .nice(4)\n          .range([chartBottom, margin.top]);\n\n      return d3\n        .scaleLinear()\n        .clamp(true)\n        .domain([\n          yBufferBottom *\n            Math.min(\n              0,\n              d3.min(dates, (date) =>\n                getStatistic(timeseries[date], chartType, statistic)\n              )\n            ),\n          Math.max(\n            1,\n            yBufferTop *\n              d3.max(dates, (date) =>\n                getStatistic(timeseries[date], chartType, statistic)\n              )\n          ),\n        ])\n        .nice(4)\n        .range([chartBottom, margin.top]);\n    };\n\n    function mousemove() {\n      const xm = d3.mouse(this)[0];\n      const date = xScale.invert(xm);\n      const bisectDate = d3.bisector((date) => parseIndiaDate(date)).left;\n      const index = bisectDate(dates, date, 1);\n      const dateLeft = dates[index - 1];\n      const dateRight = dates[index];\n      setHighlightedDate(\n        date - parseIndiaDate(dateLeft) < parseIndiaDate(dateRight) - date\n          ? dateLeft\n          : dateRight\n      );\n    }\n\n    function mouseout() {\n      setHighlightedDate(dates[T - 1]);\n    }\n\n    /* Begin drawing charts */\n    refs.current.forEach((ref, i) => {\n      const svg = d3.select(ref);\n      const t = svg.transition().duration(D3_TRANSITION_DURATION);\n\n      const statistic = TIMESERIES_STATISTICS[i];\n      const yScale = generateYScale(statistic);\n      const color = COLORS[statistic];\n\n      /* X axis */\n      svg\n        .select('.x-axis')\n        .style('transform', `translateY(${chartBottom}px)`)\n        .transition(t)\n        .call(xAxis);\n      svg.select('.x-axis2').transition(t).call(xAxis2, yScale);\n\n      /* Y axis */\n      svg\n        .select('.y-axis')\n        .style('transform', `translateX(${chartRight}px)`)\n        .transition(t)\n        .call(yAxis, yScale);\n\n      /* Path dots */\n      svg\n        .selectAll('circle')\n        .data(dates, (date) => date)\n        .join((enter) =>\n          enter\n            .append('circle')\n            .attr('fill', color)\n            .attr('stroke', color)\n            .attr('r', 2)\n            .attr('cy', chartBottom)\n            .attr('cx', (date) => xScale(parseIndiaDate(date)))\n        )\n        .transition(t)\n        .attr('cx', (date) => xScale(parseIndiaDate(date)))\n        .attr('cy', (date) =>\n          yScale(getStatistic(timeseries[date], chartType, statistic))\n        );\n\n      if (chartType === 'total') {\n        svg\n          .selectAll('.stem')\n          .transition(t)\n          .attr('y1', yScale(0))\n          .attr('y2', yScale(0))\n          .remove();\n\n        const line = d3\n          .line()\n          .curve(d3.curveMonotoneX)\n          .x((date) => xScale(parseIndiaDate(date)))\n          .y((date) =>\n            yScale(getStatistic(timeseries[date], chartType, statistic))\n          );\n\n        let pathLength;\n        svg\n          .selectAll('.trend')\n          .data(T ? [dates] : [])\n          .join(\n            (enter) =>\n              enter\n                .append('path')\n                .attr('class', 'trend')\n                .attr('fill', 'none')\n                .attr('stroke', color + '50')\n                .attr('stroke-width', 4)\n                .attr('d', line)\n                .attr('stroke-dasharray', function () {\n                  return (pathLength = this.getTotalLength());\n                })\n                .call((enter) =>\n                  enter\n                    .attr('stroke-dashoffset', pathLength)\n                    .transition(t)\n                    .attr('stroke-dashoffset', 0)\n                ),\n            (update) =>\n              update\n                .attr('stroke-dasharray', null)\n                .transition(t)\n                .attrTween('d', function (date) {\n                  const previous = d3.select(this).attr('d');\n                  const current = line(date);\n                  return interpolatePath(previous, current);\n                })\n          );\n      } else {\n        /* DAILY TRENDS */\n        svg.selectAll('.trend').remove();\n\n        svg\n          .selectAll('.stem')\n          .data(dates, (date) => date)\n          .join((enter) =>\n            enter\n              .append('line')\n              .attr('class', 'stem')\n              .style('stroke', color + '99')\n              .style('stroke-width', 4)\n              .attr('x1', (date) => xScale(parseIndiaDate(date)))\n              .attr('y1', chartBottom)\n              .attr('x2', (date) => xScale(parseIndiaDate(date)))\n              .attr('y2', chartBottom)\n          )\n          .transition(t)\n          .attr('x1', (date) => xScale(parseIndiaDate(date)))\n          .attr('y1', yScale(0))\n          .attr('x2', (date) => xScale(parseIndiaDate(date)))\n          .attr('y2', (date) =>\n            yScale(getStatistic(timeseries[date], chartType, statistic))\n          );\n      }\n\n      svg.selectAll('*').attr('pointer-events', 'none');\n      svg\n        .on('mousemove', mousemove)\n        .on('touchmove', mousemove)\n        .on('mouseout', mouseout)\n        .on('touchend', mouseout);\n    });\n  }, [chartType, dimensions, isUniform, isLog, timeseries, dates]);\n\n  useEffect(() => {\n    refs.current.forEach((ref) => {\n      const svg = d3.select(ref);\n      svg\n        .selectAll('circle')\n        .attr('r', (date) => (date === highlightedDate ? 4 : 2));\n    });\n  }, [highlightedDate]);\n\n  const getStatisticDelta = useCallback(\n    (statistic) => {\n      if (!highlightedDate) return;\n      const deltaToday = getStatistic(\n        timeseries?.[highlightedDate],\n        'delta',\n        statistic\n      );\n      if (chartType === 'total') return deltaToday;\n      const yesterday = formatISO(subDays(parseIndiaDate(highlightedDate), 1), {\n        representation: 'date',\n      });\n      const deltaYesterday = getStatistic(\n        timeseries?.[yesterday],\n        'delta',\n        statistic\n      );\n      return deltaToday - deltaYesterday;\n    },\n    [timeseries, highlightedDate, chartType]\n  );\n\n  return (\n    <React.Fragment>\n      <div className=\"TimeSeries\">\n        {TIMESERIES_STATISTICS.map((statistic, index) => {\n          const delta = getStatisticDelta(statistic);\n          return (\n            <div\n              key={statistic}\n              className={classnames('svg-parent', `is-${statistic}`)}\n              ref={wrapperRef}\n            >\n              {highlightedDate && (\n                <div className={classnames('stats', `is-${statistic}`)}>\n                  <h5 className=\"title\">{t(capitalize(statistic))}</h5>\n                  <h5 className=\"title\">\n                    {formatDate(highlightedDate, 'dd MMMM')}\n                  </h5>\n                  <div className=\"stats-bottom\">\n                    <h2>\n                      {formatNumber(\n                        getStatistic(\n                          timeseries?.[highlightedDate],\n                          chartType,\n                          statistic\n                        )\n                      )}\n                    </h2>\n                    <h6>{`${delta >= 0 ? '+' : ''}${formatNumber(delta)}`}</h6>\n                  </div>\n                </div>\n              )}\n              <svg\n                ref={(element) => {\n                  refs.current[index] = element;\n                }}\n                preserveAspectRatio=\"xMidYMid meet\"\n              >\n                <g className=\"x-axis\" />\n                <g className=\"x-axis2\" />\n                <g className=\"y-axis\" />\n              </svg>\n            </div>\n          );\n        })}\n      </div>\n    </React.Fragment>\n  );\n}\n\nconst isEqual = (prevProps, currProps) => {\n  if (!equal(currProps.chartType, prevProps.chartType)) {\n    return false;\n  }\n  if (!equal(currProps.isUniform, prevProps.isUniform)) {\n    return false;\n  }\n  if (!equal(currProps.isLog, prevProps.isLog)) {\n    return false;\n  }\n  if (!equal(currProps.stateCode, prevProps.stateCode)) {\n    return false;\n  }\n  if (!equal(currProps.dates, prevProps.dates)) {\n    return false;\n  }\n  return true;\n};\n\nexport default React.memo(TimeSeries, isEqual);\n"],"sourceRoot":""}